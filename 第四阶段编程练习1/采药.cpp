/*****
题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。
医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说： “孩子，
这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，
在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
如果你是辰辰，你能完成这个任务吗？

关于输入

输入第一行有两个整数T（1 ≤ T ≤ 1000）和M（1 ≤ M ≤ 100），用一个空格隔开，T代表总共能够用
来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整
数，分别表示采摘某株草药的时间和这株草药的价值。

关于输出

输出包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

例子输入

70 3
71 100
69 1
1 2

例子输出

3
*****/

#include <iostream>
#include <algorithm>
using namespace std;

#define MAX_N 110
#define MAX_T 1010

/**
思路 -- 动态规划

这是一道典型的背包问题--在若干价值和大小不同的物品里选择，使得有大小限制的背包装下的物品价值的和最高。
这道题目的草药价值对应物品价值，挖草药的用时对应物品大小，时间上限对应背包大小。
用dp[i][j]来记录前i个物体，用大小为j的背包，能装下的最高的价值和。显然dp[0][j] = 0。
假设dp[i-1][j]都是已知的，那么递推dp[i][j]时就有两种情况：
1. 第i件物品太大，装不进背包，那么dp[i][j] = dp[i-1][j]；
2. 第i件物品能装下，那么我们要么选择装（价值对应dp[i-1][j-size[i]]+val[i]），要么选择不装（价值对应dp[i-1][j])。
综上，我们可以从dp[1][1]开始，不断递推。最终dp[n_item][bag_size]即为所求答案。
**/

int val[MAX_N] = {0}, _time[MAX_N] = {0};
int dp[MAX_N][MAX_T]={0};

int main()
{
    int n = 0, t = 0;
    cin >> t >> n;
    for (int i = 1; i <= n; i++)
        cin >> _time[i] >> val[i];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= t; j++)
            if (_time[i] > j)
                dp[i][j] = dp[i - 1][j];
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - _time[i]] + val[i]);
    cout << dp[n][t] << endl;
    return 0;
}
