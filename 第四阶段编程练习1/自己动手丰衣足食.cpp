/*****
题目描述

经历过和S星人的交流之后，他已经对任何交流上的差异都不感到奇怪了。然而这一次，他在和一个A国同学合作
时又出现了让他大跌眼镜的事情。那个同学给他的实验数据是用科学计数法表示的，而他需要正常的保留小数点
后6位的双精度浮点数。可是不同于我们用2e5来表示200000，他们会使用任何一个字母或者数字中不会出现的字
符来表示乘方。这下可麻烦了，本来好好的用atof()函数就解决了，现在这个写好的函数就没法用，只好自己写
一个了。阿福为了这份数据已经熬了好几个通宵了，想让你趁他睡觉把这个问题处理一下，你一定可以做到的！
（助教哥哥友情提醒，题目较长，记得看提示）

关于输入

输入多个数字型的字符串，每个字符串之间换行符隔开。字符串可能包括正负符号、小数点以及代表乘方的字符
（不是数字，正负号，小数点）。
对输入的字符串进行转换时，遇见数字、小数点或正负符号就开始做转换，字符串结束时才结束转换，并将结果
返回。
当输入字符'q'时，程序结束。

关于输出

double型浮点数，显示小数点后六位。
当为正数时，浮点数第一位不显示'+'。
当为负数时，浮点数第一位显示'-'.

例子输入

+2343.12
-2.36542
-5.21
6.348
+0.564f5
+0.456
-25.1f-5
q

例子输出

2343.120000
-2.365420
-5.210000
6.348000
56400.000000
0.456000
-0.000251

提示信息

注意：本题严禁使用stdlib.h中的atof()函数，否则不得分。
*****/

#include <cstdio>
#include <cstring>

#define MAX_LEN 1000

char buf[MAX_LEN] = "\0";

int main()
{
    double num = 0;
    while (scanf("%[^\n]", buf) != EOF)
    {
        if (!strcmp("q", buf))
            return 0;
        for (int i = 0; buf[i] != '\0'; i++)
            if (!(buf[i] >= '0' && buf[i] <= '9') && buf[i] != '+' && buf[i] != '-' && buf[i] != '.')
            {
                buf[i] = 'e';   // 将不规范的形式改为规范的科学技术法形式
                break;
            }
        sscanf(buf, "%lf", &num);   // 将字符串转为double
        printf("%.6lf\n", num);
        scanf("%s", buf);   // 读取缓冲区回车
    }
    return 0;
}
