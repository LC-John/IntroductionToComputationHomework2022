/*****
题目描述

小明在家十分无聊，他发现他手边有如下所示的电话拨号盘
    | 1 | 2 | 3 |
    | 4 | 5 | 6 |
    | 7 | 8 | 9 |
         | 0 |
和一个象棋棋子“马”
他先将“马”放在电话拨号盘的任意键上，接下来，棋子将会按照“马走日”的方式跳 N-1 步。
每一步必须是从一个数字键跳到另一个数字键，例如可以从1跳到8或6，而从5不能跳到其他任何
地方。
每当它落在一个键上（包括初始位置），都会拨出键所对应的数字，总共按下 N 位数字。
请问小明能用这种方式拨出多少个不同的号码？

关于输入

输入一个整数N，表示马跳的步数。

关于输出

输出小明能拨出的号码总数

例子输入

2

例子输出

20

提示信息

N=1时，第一步棋子可落在{1， 2， 3， 4， 5， 6， 7， 8， 9， 0}一共10个位置上。
N=2时，第一步棋子可落在{1， 2， 3， 4， 6， 7， 8， 9， 0}一共9个位置上。
第二步，从1出发的棋子可落在6或8，拨出16或18；
从2出发的棋子可落在7或9，拨出27或29；
从3出发的棋子可落在4或8，拨出34或38；
从4出发的棋子可落在3或9或0，拨出43或49或40；
从6出发的棋子可落在1或7或0，拨出61或67或60；
从7出发的棋子可落在2或6，拨出72或76；
从8出发的棋子可落在1或3，拨出81或83；
从9出发的棋子可落在2或4，拨出92或94；
从0出发的棋子可落在4或6，拨出04或06。一共是20种拨号方式。

由与5不能跳到其他任何位置，其他任何位置也不能跳到5，当N>1时，初始位置不会选择5。
我们输入保证2<=N<=20
*****/

#include <iostream>
using namespace std;

#define N_DIGIT 10
#define MAX_N 30

/**
思路 -- 动态规划

假设有二维数组dp，dp[i][j]表示共i步且马的起始位置在j时共有几种跳法。
显然，dp[1][j] = 1，因为马不需要跳，直接放到拨号盘上的j位置即可。
假设对任意的j，dp[i-1][j]都已经求解完成，考虑如何计算dp[i][j]。
从j位置出发跳一步后到j'位置，之后共有dp[i-1][j']种跳法，那么考虑所有j'即可：
dp[i][j] = sum_j'(dp[i-1][j']), where j' is a legal jump from j
**/

int jump[N_DIGIT][N_DIGIT] =
{
    {4, 6, -1},     // 0
    {6, 8, -1},     // 1
    {7, 9, -1},     // 2
    {4, 8, -1},     // 3
    {0, 3, 9, -1},  // 4
    {-1},           // 5
    {0, 1, 7, -1},  // 6
    {2, 6, -1},     // 7
    {1, 3, -1},     // 8
    {2, 4, -1},     // 9
};
int dp[MAX_N][N_DIGIT] = {0};

int main()
{
    int n = 0, ans = 0;
    cin >> n;
    for (int i = 0; i < N_DIGIT; i++)
        dp[1][i] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 0; j < N_DIGIT; j++)
            for (int k = 0; jump[j][k] >= 0; k++)
                dp[i][j] += dp[i - 1][jump[j][k]];
    for (int i = 0; i < N_DIGIT; i++)
        ans += dp[n][i];
    cout << ans << endl;
    return 0;
}
