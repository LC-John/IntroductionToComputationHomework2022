/*****
题目描述

以前大学食堂都使用餐票吃饭，每顿饭菜钱可以为1角，2角，...，最多为n角。如果规定每次吃
饭最多只能使用k张餐票，是否可以设计m种不同面值的餐票，使得餐票从1开始可以连续覆盖的面
值范围恰好为 1 - n（角）？满足上述条件的方案有多少？
假设 n 的值不超过500，饭菜钱单位为角。
例如，
m=3, k=2, n=8, 则，面值为：{1,3,4} 恰好覆盖 1,2,...,8，此时，1角只需要1张面值为1的
即可，2角需要2张面值为1的，3角只需要1张面值为3的，4角只需要1张面值为4的，5角需要1张
面值为1的再加上1张面值为4的，6角需要2张面值为3的，7角需要1张面值为3再加上1张面值为4
的，8角需要2张面值为4的。即：只需要2张面值的饭票即可覆盖1-8的范围（注意：一定是连续
覆盖）。除了这三种面值之外，再没有其他方案的面值。因此，这样的方案有1种。
若m=3, k=2, n=9, 则不存在面值组合，因此，为0种方案。
若m=3, k=2, n=6,则有 {1,2,3}，{1,2,4}和{1,3,5}共3种。
若m=3, k=2, n=5, 则不存在，因此，为0种。

关于输入

第1行输入正整数 P, 表示后面有 P行
后面的P行分别为 m,k，n,其间以空格间隔

关于输出

对应输出 P行，若不存在 m 种面值的饭票，则输出0，若有，则输出方案数。

例子输入

4
3 2 5
3 2 6
3 2 8
3 2 9

例子输出

0
3
1
0

提示信息

注意代码运行效率，可以注意对一些重复操作进行优化。
*****/

#include <iostream>
using namespace std;

#define MAX_N 1000

int ac[MAX_N] = {0}, p[MAX_N] = {0};
int n = 0, m = 0, k = 0, ans = 0;

void dfs(int x,int mx)
{
	if(mx < 0)
        return;
	if(x > m)
    {
		if(mx == n)
            ans++;
		return;
	}
    int *tmp = new int[MAX_N];
	for(int i = p[x - 1] + 1;i <= mx + 1; i++)
    {
		p[x] = i;
		int r = min(i * k, n + 1), j = 0;
		for(j = i; j <= r; j++)
		{
			tmp[j] = ac[j];
			ac[j] = min(ac[j], ac[j - i] + 1);
		}
		if(ac[n + 1] > k)
		{
			for(j = i; j <= r + 1; j++)
				if(ac[j] > k)
				{
					dfs(x + 1, j - 1);
					break;
				}
		}
		for(j = i; j <= r; j++)
            ac[j] = tmp[j];
	}
}

int main()
{
	int t = 0;
	cin >> t;
	while(t--)
    {
		cin >> m >> k >> n;
		ans = 0;
		for(int i = 1; i <= n + 1; i++)
            ac[i] = n + n;
		for(int i = 0; i <= k; i++)
            ac[i]=i;
		p[1] = 1;
		dfs(2, k);
		cout << ans << endl;
	}
	return 0;
}
