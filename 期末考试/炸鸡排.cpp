/*****
题目描述

小P买了n块鸡排，想将它们做成美味的炸鸡排，其中第i块鸡排需要t[i]秒炸熟。小P只有一
个炸锅，炸锅内可以放置k(k≤n)块鸡排。小P是个完美主义者，他要求任意时刻炸锅内必须
恰有k块鸡排。他可以在任意时刻改变锅内正在炸的鸡排，只需保证已经熟了的鸡排不能继续
留在锅中。小P希望知道炸鸡排最多可以持续多少时间。
例如，小P的三块鸡排需要分别需要1,1,1的时间炸熟，炸锅内需要放置2块鸡排，那么他决定
在第一个0.5秒炸1和2两块鸡排，第二个0.5秒炸2和3两块鸡排，第三个0.5秒炸1和3两块鸡排，
共持续了1.5秒。

关于输入

第一行输入两个正整数n和k，k≤n
第二行输入n个正整数，代表n块鸡排分别需要炸熟的时间t[1],t[2]...t[n]
输入数据保证，n≤1000，0＜t[i]≤1000000

关于输出

输出一个双精度浮点数，代表炸鸡排最多可以持续的时间，结果保留三位小数。

例子输入

4 2
5 1 1 2

例子输出

4.000

提示信息

样例说明：
第1秒，放置1和2
第2秒，放置1和3
第3、4秒，放置1和4
至此，2，3，4已经全部熟了，无法继续进行
*****/

#include <cstdio>
#include <algorithm>
using namespace std;

#define MAX_N 1010

int t[MAX_N] = {0};

int main()
{
    int k = 0, n = 0;
    scanf("%d%d", &n, &k);
    double sum = 0;
    for(int i = 0; i < n; i++)
    {
        scanf("%d", &(t[i]));
        sum += t[i];
    }
    sort(t, t + n);
    if(t[n - 1] <= sum / k)
        printf("%.3lf", sum / k);
    else
    {
        for (int i = n - 1; i >= 0 && sum / k < t[i]; i--)
        {
            sum -= t[i];
            k--;
        }
        printf("%.3lf", sum / k);
    }
}
