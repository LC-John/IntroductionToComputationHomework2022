/*****
题目描述

卡塔尔世界杯正在火热进行中，P大富哥李哥听闻有一种叫"肤白·态美·宇宙无敌·世界杯·预测鸡"的鸡品种（以下
简称为只因）有概率能准确预测世界杯赛果，一口气买来无数只只因，并把它们塞进了N个只因窝里，但只因窝实在太
多了，李哥需要安装摄像头来观测里面的只因的预测行为。
具体来说，李哥的只因窝可以看作分布在一条直线上的N个点，编号为1到N。由于每个只因窝的结构不同，在编号为i
的只因窝处安装摄像头，观测范围为a_i，其中a是长为N的整数列，表示若在此安装摄像头，可以观测到编号在
[ i - a_i ,  i + a_i ]（闭区间）内的所有只因窝。
李哥觉得摄像头成本高，决定抠门一下，请你来帮忙看看最少需要安装多少个摄像头，才能观测到全部N个只因窝。作
为回报，他会请你喝一杯芋泥波波牛乳茶。

关于输入

第一行：一个正整数，代表有N个只因窝。
第二行给出数列a：N个非负整数，第i个数代表a_i，也就是在第i个只因窝装摄像头能观测到的区间的半径。
数据保证 N ≦ 500000，0 ≦ a_i ≦ N

关于输出

一个整数，即最少需要装的摄像头数量。

例子输入

10
2 0 1 1 0 3 1 0 2 0

例子输出

3

提示信息

由于数据量较大，建议使用scanf进行读入，即
int n;
scanf("%d", &n);
请注意所使用算法的运行效率
彩蛋：只因们很喜欢那个穿着蓝白球衣长得像黄金矿工的10号
*****/

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define MAXN 500500

int dp[MAXN] = {0};

int main()
{
    int n = 0, s = 0, l = 0, r = 0;
    scanf("%d", &n);
    memset(dp, 0x7f, sizeof(dp));
    dp[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &s);
        l = max(1, i - s);
        r = min(n, i + s);
        if (dp[r] > dp[l - 1] + 1)
            for (int j = l; j <= r; j++)
                dp[j] = min(dp[j], dp[l - 1] + 1);
        if (dp[n] < 0x7f7f7f7f)
            break;
    }
    printf("%d\n", dp[n]);
    return 0;
}
