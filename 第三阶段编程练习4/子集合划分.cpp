/*****
题目描述
将一个没有重复元素的集合A分成若干个非空子集，使得A中每个元素属于且仅属于一个子集，
那么这些子集构成的集合称为A的一个划分。现在给定集合的元素个数n，希望知道有多少种不
同的划分（假定集合本身属于一种划分），当n=0的时候，也认为有一种划分。
例如，n=3 时，A={1，2，3}的所有划分如下：
{ {1} ， {2} ， {3} }
{ {1 ， 2} ， {3} }
{ {1 ， 3} ， {2} }
{ {1} ， {2 ， 3} }
{ {1 ， 2 ， 3} }
一共有5种。

关于输入

若干行整数，每行一个整数n，当为-1时结束

关于输出

每行对应的集合划分数（假设可以用long表示）

例子输入

0
3
13
-1

例子输出

1
5
27644437
*****/

#include <iostream>
using namespace std;

#define MAX_N 300

/**
思路

使用动态规划（dp），用二维数组dp来记录状态。
dp[i][j]表示将i个不同的元素分成j个集合的划分方法数。

显然有
dp[0][0] = 1
dp[1][0] = 0
dp[1][1] = 1
...

进一步，可以发现有如下递推关系
dp[i][j] = = dp[i - 1][j - 1] + j * dp[i - 1][j], i > 1 and 0 < j <= i
在i-1个元素的划分数已知的前提下，将i个元素分成j个集合，其实就是如何将多出来的元素划分的问题
有两种情况：
1. 多出来的元素自己成为一个新的集合，其它i-1个元素分成j-1个集合（即dp[i-1][j-1]）
2. 多出来的元素进入已有的一个集合，其它i-1个元素分成j个集合，而多出来的元素进入这j个集合中的哪一个都可以（即j*dp[i-1][j]）
**/

long long dp[MAX_N][MAX_N]={{1}, {0, 1}};   // dp数组
int n_dp = 2;                               // n_dp表示当前还没有计算的最小的元素数

int main()
{
	int n = 0;
	int ans = 0;
	while(cin >> n)
	{
		if(n < 0)       // 退出
            return 0;
        ans = 0;
        if (n >= n_dp)  // 若n大于等于n_dp，说明dp没有覆盖住n，那么就需要继续计算dp
        {
            for(int i = n_dp; i <= n; i++)                          // 从上向下
                for(int j = 1;j <= i; j++)                          // 从左到右
                    dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j]; // 计算dp
            n_dp = n;                                               // 更新n_dp
        }
        for(int i = 0; i <= n; i++)     // 将dp[n]整行相加
            ans = ans + dp[n][i];       // 得到所有划分数
        cout << ans << endl;
	}
	return 0;
}
