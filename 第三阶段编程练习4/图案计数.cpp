/*****
题目描述

一张画布里有n行*m列个格子，其中有的格子里有颜色填充，有的格子是空的没有颜色填充。
现在需要你写一个程序来数出画布里边有颜色填充的格子构成了多少个图案，其中图案的定
义为：
如果两个有颜色的格子边相邻或者角相邻（即横、纵两个方向上的位置差都不超过1），则
他们属于同一个图案。

关于输入

第一行为两个整数n和m（1<=n, m<=200）。
之后的n行，每行为一个长度为m的字符串，构成了整个画布。字符串中，#表示颜色，-表示空白。

关于输出

一个整数，表示图案的个数

例子输入

19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------

例子输出

12
*****/

#include <iostream>
#include <cstring>
using namespace std;

#define MAX_N 300
#define COLOR '#'
#define EMPTY '-'
#define ND 8

char arr[MAX_N][MAX_N] = {""};
int row = 0, col = 0;
int dr[ND] = {0, 0, 1, -1, 1, 1, -1, -1};
int dc[ND] = {1, -1, 0, 0, 1, -1, 1, -1};

/** 深度优先搜索，移除当前图案 **/
void dfs(int r, int c)
{
    if (arr[r][c] == EMPTY)
        return;
    arr[r][c] = EMPTY;
    for (int d = 0; d < ND; d++)
        dfs(r + dr[d], c + dc[d]);
}

int main()
{
    int cnt = 0;
    cin >> row >> col;
    memset(arr, EMPTY, sizeof(arr));
    for (int i = 1; i <= row; i++)
        for (int j = 1; j <= col; j++)
             cin >> arr[i][j];
    for (int i = 1; i <= row; i++)
        for (int j = 1; j <= col; j++)
            if (arr[i][j] == COLOR)     // 每当遇到颜色图案
            {
                cnt++;                  // 图案计数加一
                dfs(i, j);              // 移除该图案
            }
    cout << cnt << endl;
    return 0;
}
