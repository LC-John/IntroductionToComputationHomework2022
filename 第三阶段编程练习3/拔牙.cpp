/*****
题目描述

浩助教当了一学期的口腔二班助教，有一天，他突然对各种动物的牙齿颗数产生了兴趣，经过查阅资料，
他发现，一般成人有32颗牙齿，狗有42颗牙齿，鳄鱼有66颗牙齿，蜗牛据说有25600颗牙齿。
OK，假设你是一名优秀的牙医，目标是将某种动物所有的n颗牙齿全部拔掉，考虑到患者的感受，每个月
只能拔掉1颗或者2颗牙齿，直到拔完为止，你的任务是写一个程序，求一共有多少种不同的拔牙方式。
例如有3颗牙齿，你可以选择第一个月拔掉1颗，第二个月拔掉2颗，也可以选择第一个月拔掉2颗，第二个
月拔掉1颗，也可以选择三个月每个月拔1颗。这样一共有3种拔牙方式。

关于输入

输入只有一行，表示牙齿的颗数n（0 < n < 30）。

关于输出

输出所有可能的拔牙方式的种类数。

例子输入

4

例子输出

5

提示信息

可以考虑递归，将原问题根据拔1颗或者拔2颗分成两个子问题。
*****/

#include <iostream>
using namespace std;

/**
思路

我们可以发现拔i颗牙（i >= 3）的种类数，是拔i-1颗的种类数加上拔i-2颗的种类数。
显然，拔1颗牙的种类数是1，拔两颗牙的种类数是2，那么就可以不断向后计算拔i颗牙的种类数。

计拔i颗牙的种类数为f(i)，那么f(i)的计算方式如下：
f(i) = f(i - 1) + f(i - 2), if i > 2
f(1) = 1, f(2) = 2

这种思路就是动态规划，通过一个大小为n的dp数组从前往后计算。
这里我们用循环数组，可以进一步节省内存开销。
**/

int dp[3] = {1, 1, 2};  // dp[i % 3]存放了f(i)

int main()
{
    int n = 0;
    cin >> n;
    for (int i = 3; i <= n; i++)
        dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3];
    cout << dp[n % 3] << endl;
    return 0;
}
