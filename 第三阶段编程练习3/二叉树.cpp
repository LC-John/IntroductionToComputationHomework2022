/*****
题目描述

如上图所示，由正整数1, 2, 3, ...组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条
唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路
径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, ... ,1)和
(y1, y2, ... ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有
xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,... 现在的问题就是，给定x和y，要求xi（也就是yj）。

关于输入

输入只有一行，包括两个正整数x和y，这两个正整数都不大于1000。

关于输出

输出只有一个正整数xi。

例子输入

10 4

例子输出

2
*****/

#include <iostream>
using namespace std;

/**
思路

简单观察，便可以发现，对于任意一个节点i，它的父节点总是i / 2（int类型下）。
那么我们不断去让a和b中较大的节点向上走到其父节点，直到a与b重合即可。
**/

int main()
{
    int a = 0, b = 0;
    cin >> a >> b;
    while (a != b)
        if (a > b)
            a /= 2;
        else
            b /= 2;
    cout << a << endl;
    return 0;
}
