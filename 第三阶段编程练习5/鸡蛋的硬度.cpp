/*****
题目描述

最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。参赛者是来自世 界各地的母鸡，比赛的内容是看谁下的蛋最硬，
更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法--从高度扔鸡蛋--来 测试鸡蛋的硬
度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。
你当然可以找出各种 理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，
因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当
然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样--这比赛不过是XX 公司的一个另类广告而已。
勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。“假如有很多同样硬度的鸡蛋，那么我可以用二分
的办法用最少的次数测出鸡蛋 的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不
够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一 层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，
那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定 啊……3个鸡蛋怎么办，
4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。
好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了：）

关于输入

输入包括多组数据，每组数据一行，包含两个正整数n和m(1 <= n <= 100,1 <= m <= 10)，其中n表示楼的高度，m表示你现
在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于n。你可以假
定硬度为x的鸡蛋从高度小于等于x的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比x高的地方扔必然
会碎。
对每组输入数据，你可以假定鸡蛋的硬度在0至n之间，即在n+1层扔鸡蛋一定会碎。

关于输出

对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。

例子输入

100 1
100 2

例子输出

100
14

提示信息

最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。
如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你
可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要
扔无限次，所以第一组数据的答案是100。
*****/

#include <iostream>
#include <algorithm>
using namespace std;

#define MAX_N 200
#define MAX_M 20
#define MAX_INT 0x7fffffff

/**
思路：动态规划

dp[i][j]表示共i层楼j个鸡蛋时最优策略的扔鸡蛋的次数。显然dp[i][1] = i（共i层楼1个鸡蛋最优策略是扔i次）, dp[1][i] = 1。
要计算dp[i][j]，可以综合从1楼到i楼都扔一次的结果，在里面取最优即可。假设在k楼扔了一个鸡蛋，会出现两种情况：
1. 若鸡蛋碎了，那么就需要在更低的楼层（1到k-1层）继续测试，扔鸡蛋的次数就是dp[k-1][j-1] + 1；
2. 若鸡蛋没碎，那么就需要在更高的楼层（k+1到i层）继续测试，扔鸡蛋的次数就是dp[i-k][j] + 1。
对于每一个k来说，最坏情况是上面的二者中扔鸡蛋次数较多的；对于所有k来说，最优解应该是扔鸡蛋的次数最少的。
因此dp[i][j] = min_k(max(dp[k-1][j-1] + 1, dp[i-k][j] + 1))。
**/

int dp[MAX_N][MAX_M] = {0};
int cur_n = 0, cur_m = 0;

int main()
{
    int n = 0, m = 0;
    for (int i = 1; i < MAX_N; i++)
        dp[i][1] = i;
    for (int i = 1; i < MAX_M; i++)
        dp[1][i] = 1;
    for (int i = 2; i < MAX_N; i++)
        for (int j = 2; j < MAX_M; j++)
            dp[i][j] = MAX_INT;
    for (int i = 2; i < MAX_N; i++)
        for (int j = 2; j < MAX_M; j++)
            for (int k = 1; k <= i; k++)
                dp[i][j] = min(dp[i][j], 1 + max(dp[k - 1][j - 1], dp[i - k][j]));
    while (cin >> n >> m)
        cout << dp[n][m] << endl;
    return 0;
}
