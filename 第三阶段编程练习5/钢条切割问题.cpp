/*****
题目描述

Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最
佳的切割方案。假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。
钢条的长度均为整英寸。
给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。

关于输入

第一行：n，表示购买的长钢条的长度。
接下来一行包含 n 个数字，第 i 个数字出售长为 i 的钢条的价格，即 pi。
其中 0 < n <= 3000，0 < pi <= 10000。

关于输出

输出仅一行，为最大的销售收益值 rn。

例子输入

7
1 5 8 9 10 17 17

例子输出

18

提示信息

注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。
*****/

#include <iostream>
#include <cmath>
using namespace std;

#define MAX_N 5000

/**
思路：动态规划

用dp[x]表示长度为x的钢条在最优切割方案下可以卖出的价格。显然，dp[0] = 0。
假设长度为dp[1]到dp[L - 1]都是已知的，求dp[L]就只需要考虑如下的两种情况：
1. 不切割，直接出售长度为L的钢条；
2. 将L切成L1和L2两段（0 < L1 <= l2 < L），每一段都按已知的最优dp[L1]和dp[L2]进行切割。
那么显然就有：
    dp[L] = max(p[L], dp[1] + dp[L - 1], dp[2] + dp[L - 2], ...)

基于上面的推理，我们不难发现可以从dp[1]开始，从小到大计算dp[x]，最终dp[n]就是所需要的答案。
**/

int dp[MAX_N] = {0};
int p[MAX_N] = {0};

int main()
{
    int n = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> p[i];
    dp[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        dp[i] = p[i];   // 不切割
        for (int j = 1; j + j <= i; j++)    // 只用考虑i的一半，避免重复计算
            dp[i] = max(dp[i], dp[j] + dp[i - j]);  // 将i切割为j和i - j两段
    }
    cout << dp[n] << endl;
    return 0;
}
